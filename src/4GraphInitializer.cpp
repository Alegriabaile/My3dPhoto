//
// Created by ale on 19-11-22.
//

#include "0transform.h"
#include "1Logger.h"
#include "4GraphInitializer.h"

//using namespace cv;
//using namespace std;

namespace m3d
{

    GraphInitializer::GraphInitializer(std::vector<m3d::Frame> &frames_, m3d::Graph &graph_)
    :frames(frames_), graph(graph_)
    {
        ActivateEdges();
        GenInitViaMst();
    }
    GraphInitializer::~GraphInitializer(){}


    bool GraphInitializer::IsActiveEdge(const m3d::Edge &edge)
    {
        //more reliable judgement methods needed...
        //todo

        //to run the dataset for MI-3d-photo-project
        double gmsInliersNo = edge.matches[0];
        double allPairsNo = edge.matches[1];

        if(gmsInliersNo < 100)
            return false;

        double deltaRotation = edge.translations[0];//Delta Rotation of angle-axis.
        if(deltaRotation < 0.1 || deltaRotation > 0.5)
            return false;

        return true;
    }

    void GraphInitializer::ActivateEdges()
    {
        std::vector<Edge> &edges = graph.edges;
        std::vector<bool> &activated = graph.activatedEdges;
        DisjointSets &disjointSets = graph.disjointSets;

        size_t sz = edges.size();
        for(size_t i = 0; i < sz; ++i)
            activated[i] = IsActiveEdge(edges[i]);
    }

    //input:(Vs, Es) vertices and edges of the max connected component graph
    //output:(Es) minimum spanning tree generated by Prim's algorithm, sorted by delta rotation.
    void GraphInitializer::GenMstViaPrim(const std::set<size_t> &Vs, std::vector<m3d::Edge> &Es)
    {
        //sort Edges.
        size_t sz = Es.size();
        if(sz == 0)
        {
            LOG("GraphInitializer::GenMstViaPrim(): ", "Es.size() == 0");
            exit(-1);
        }

        //bubble sorting of edges from one connected component graph.
        for(size_t i = 0; i< sz; ++i)
            for(size_t j = 0; j < sz - i - 1; ++j)
                if(Es[j].translations[0] > Es[j + 1].translations[0])
                    std::swap(Es[j], Es[j + 1]);
//        for(size_t i=0; i<sz; ++i)
//            std::cout<<"\t"<<i<<" th translation after bubble: "<<Es[i].translations[0]<<std::endl;

        //Prim's algorithm.
        std::set<size_t > Vs1;
        std::vector<Edge> Es1;
        std::vector<bool> visitedEs(sz, false);
        //Vs.size - 1 edges ------> Vs.size vertices.
        Es1.push_back(Es[0]);
        Vs1.insert(Es[0].src), Vs1.insert(Es[0].dst);
        size_t vsz = Vs.size();
        for(size_t i = 0; i < vsz - 2; ++i)
        {
            for(size_t j = 0; j < sz; ++j)
            {
                if(!visitedEs[j] &&//
                    ( (Vs1.find(Es[j].src) != Vs1.end()) ^ (Vs1.find(Es[j].dst) != Vs1.end()) ) )//a v is in and another v is out.
                {
                    Es1.push_back(Es[j]);
                    Vs1.insert(Es[j].src);
                    Vs1.insert(Es[j].dst);

                    visitedEs[j] = true;
                    break;
                }
            }
        }

        //ascending ordered mst, output to Es.
        std::swap(Es, Es1);
    }

    void GraphInitializer::GenMstViaPrim(const std::vector<bool> &activatedFrames, const std::vector<bool> &activatedEdges, const std::vector<m3d::Edge> &edges,
            std::vector<bool> &activatedEdgesMst)
    {
        size_t esz = 0;
        std::vector<std::pair<size_t , double>> sortedEdges;
        for(size_t i=0; i<activatedEdges.size(); ++i)
            if(activatedEdges[i])
            {
                sortedEdges.push_back(std::pair<size_t, double>(i, edges[i].translations[0]));
                ++esz;
            }
        if(esz == 0)
        {
            LOG("GraphInitializer::GenMstViaPrim(): ", "Es.size() == 0");
            exit(-1);
        }

        //sorting of edges from one connected component graph.
        auto compare_ascending = [] (std::pair<size_t, double> a, std::pair<size_t, double> b) { return a.second < b.second;};//
        std::sort(sortedEdges.begin(), sortedEdges.end(), compare_ascending);
//        for(size_t i=0; i<sz; ++i)
//            std::cout<<"\t"<<i<<" th translation after bubble: "<<Es[i].translations[0]<<std::endl;

        //Prim's algorithm.
        size_t vsz = 0;
        for(size_t i=0; i<activatedFrames.size(); ++i)
            if(activatedFrames[i])
                ++vsz;

        std::vector<bool> visitedVs(activatedFrames.size(), false);
        //Vs.size - 1 edges ------> Vs.size vertices.
        activatedEdgesMst[sortedEdges[0].first] = true;
        visitedVs[edges[sortedEdges[0].first].src] = visitedVs[edges[sortedEdges[0].first].dst] = true;
        for(size_t i = 0; i < vsz - 2; ++i)
        {
            for(size_t j = 0; j < esz; ++j)
            {
                size_t eIndex = sortedEdges[j].first;
                size_t src = edges[eIndex].src;
                size_t dst = edges[eIndex].dst;
                if(!activatedEdgesMst[eIndex] &&//
                   visitedVs[src] ^ visitedVs[dst] )//a v is in and another v is out.
                {
                    activatedEdgesMst[eIndex] = true;
                    visitedVs[src] = true;
                    visitedVs[dst] = true;

                    break;
                }
            }
        }
    }

    //src(V0) ----R,t----> dst(V1).
    //R0V0 + t0 --------> V1.
    //R1(V1) + t1 --------> world(0, 0, 0).
    //R1R0V0 + R1t0 + t1 --------> world.
    //R1R0 = Rsrc, R1t0 + t1 = tsrc.

    //dst(V1) ----R, t----> src(V0)
    //R0-1V1 + (-R0-1t0) --------> V0.

    void GraphInitializer::GenPosesFromMst()
    {
        const std::vector<bool> &activatedEdgesMst = graph.activatedEdgesMst;
        const std::vector<bool> &activatedFrames = graph.activatedFrames;
        const std::vector<Edge> &edges = graph.edges;
        size_t src, dst;

        size_t esz, vsz;
        esz = vsz = 0;

        std::vector<SimpleEdge> mstEdges;
        for(size_t i=0; i<activatedEdgesMst.size(); ++i)
            if(activatedEdgesMst[i])
            {
                src = edges[i].src;
                dst = edges[i].dst;
                const double *rts = edges[i].rts;
                SimpleEdge simpleEdge(src, dst, rts);
                mstEdges.push_back(simpleEdge);

                ++esz;
            }

        vsz = esz + 1;
        std::set<size_t > mstVertices;

        //initialize the first edge.
        src = mstEdges[0].src;
        dst = mstEdges[0].dst;
        mstVertices.insert(src);
        mstVertices.insert(dst);
        m3d::RelativeToGlobal(frames[dst].extrinsicD.transform(), mstEdges[0].rts, frames[src].extrinsicD.transform(), true);

        //todo
        //add all edges to global graph.
        while(mstVertices.size() < vsz)
        {
            for(size_t i = 0; i < mstEdges.size(); ++i)
            {
                src = mstEdges[i].src;
                dst = mstEdges[i].dst;
                if(mstVertices.find(src) == mstVertices.end() ^ mstVertices.find(dst) == mstVertices.end())
                {
                    if(mstVertices.find(src) != mstVertices.end())
                    {
                        const double * const globalPose = frames[src].extrinsicD.transform();
                        const double * const relativePose = mstEdges[i].rts;
                        double* res = frames[dst].extrinsicD.transform();
                        bool fSrc2Dst = false;
                        m3d::RelativeToGlobal( globalPose, relativePose, res, fSrc2Dst);
                    }else
                    {
                        const double * const globalPose = frames[dst].extrinsicD.transform();
                        const double * const relativePose = mstEdges[i].rts;
                        double* res = frames[src].extrinsicD.transform();
                        bool fSrc2Dst = true;
                        m3d::RelativeToGlobal( globalPose, relativePose, res, fSrc2Dst);
                    }
                    mstVertices.insert(src);
                    mstVertices.insert(dst);
                    break;
                }
            }
        }
    }

    void GraphInitializer::GenInitViaMst()
    {
        std::vector<Edge> &edges = graph.edges;
        std::vector<bool> &activatedEdges = graph.activatedEdges;

        std::vector<bool> &activatedFrames = graph.activatedFrames;
        std::vector<bool> &activatedEdgesMst = graph.activatedEdgesMst;
        DisjointSets &disjointSets = graph.disjointSets;

        //disjoint set, cut the frames to connected graphs
        size_t esz = edges.size();
        for(size_t i = 0; i<esz; ++i)
            if(activatedEdges[i])
                disjointSets.Union(edges[i].src, edges[i].dst);

        //find the max graph(decided by vertices/frames).
        size_t parentOfDisjointSet = disjointSets.getMaxSetParent();
        size_t vsz = activatedFrames.size();


        //get the vertices/frames of the max graph.
        /*
        std::set<size_t> Vs;
        std::vector<Edge> Es;
        for(size_t i=0; i<vsz; ++i)
            if(disjointSets.Find(i) == parentOfDisjointSet)
                Vs.insert(i);

        esz = edges.size();
        for(size_t i=0; i<esz; ++i)
            if(activatedEdges[i])
                Es.push_back(edges[i]);

        //Prim's algorithm of minimum spanning tree.
        GenMstViaPrim(Vs, Es);
        for(size_t i=0; i<Es.size(); ++i)
            std::cout<<i<<" th: "<<Es[i].src<<", "<<Es[i].dst<<": "<<Es[i].translations[0]<<std::endl;
        */

        //
        for(size_t i=0; i<vsz; ++i)
            if(disjointSets.Find(i) == parentOfDisjointSet)
                activatedFrames[i] = true;
        //Prim's algorithm of minimum spanning tree.
        GenMstViaPrim(activatedFrames, activatedEdges, edges, activatedEdgesMst);
//        for(size_t i=0; i<activatedEdgesMst.size(); ++i)
//            if(activatedEdgesMst[i])
//                std::cout<<i<<" th activatedEdgesMst: "<<edges[i].src<<", "<<edges[i].dst<<": "<<edges[i].translations[0]<<std::endl;

        //todo
        //get initial&&global pose from the mst edges.
        GenPosesFromMst();

    }

}